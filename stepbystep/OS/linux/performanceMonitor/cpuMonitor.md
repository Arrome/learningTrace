# cpu监控
===============================
##平均负载
平均负载：（和CPU使用率没有直接关系）
    单位时间内，系统处于可运行状态（正在使用CPU和正在等待CPU的进程）和不可中断状态（正处于内核态关键流程中的，比如等待硬件设别IO响应）的平均进程数（平均活跃进程数）。
    平均负载理想情况等于CPU个数。（一般平均负载高于CPU数量70%，应该分析排查负载问题）
`uptime`
---------
系统当前时间，主机已运行时间，用户连接数，系统平均负载（最近1,5,15分钟的系统平均负载）<br>

cat /proc/loadavg
---------------
1,5,15分钟内的平均进程数，分子表示正在运行的进程数，分母表示进程总数，最近运行的进程ID号

##CPU使用率
*top
----------
**优势**：从进程上了解CPU使用率概况<br>

包含CPU使用率（`uptime命令`），进程统计数据，内存使用率
> 上半部分是整个系统的统计信息<br>
> 下半部分是进程统计信息(默认按CPU使用率由高到低排序)


*mpstat
------
监控每个虚拟处理器CPU使用率，有助于发现应用中是一些线程比其他线程消耗更多的CPU周期，还是应用中所有线程基本平分CPU周期。<br>
>大多linux发行版需要安装sysstat包才能使用mpstat
1. usr 执行用户代码时用CPU时间百分比
2. sys 执行内核代码时用CPU时间百分比
3. wt  I/O等待时间的百分比
4. idl CPU空闲时间的百分比

=================================
## CPU调度程序运行队列
**优势**：
  分辨系统是否满负荷(准备运行的轻量级进程数超过系统所能处理上限，运行队列就很长，表明系统负荷可能已饱和)<br>

**指导原则**：
1. 如果很长一段时间里，运行队列长度一直都超过虚拟处理器个数的1倍，就需要关注，只是暂时还不需要立刻采取行动。
2. 如果很长一段时间里，运行队列的长度达到虚拟处理器个数的3~4倍或更高，则需要立即引起注意或采取行动<br>

**解决运行队列长方法**：
1. 增加CPU，以分担负载或减少处理器的负载量
2. 分析系统运行的应用，改进CPU使用率(如减少垃圾收集的频度或采用完成相同任务但CPU指令更少的算法)

> 虽然现代JIT编译器可以产生成熟优化的代码以改善应用性能，但Java程序员几乎无法操纵JIT编译器，所以应该关注算法和数据结构的效率

vmstat
--------
第一列是运行队列长度，值是运行队列中轻量级进程实际数量

常用CPU监控脚本
--------------------------
**1小时内占用CPU最多的10个进程**
```
#!/bin/bash
#文件名: pcpu_usage.sh
#用途:计算1个小时内进程的CPU占用情况
SECS=3600
UNIT_TIME=60
#将SECS更改成需要进行监视的总秒数
#UNIT_TIME是取样的时间间隔,单位是秒
STEPS=$(( $SECS / $UNIT_TIME ))
echo Watching CPU usage... ;

for((i=0;i<STEPS;i++))
do
ps -eo comm,pcpu | tail -n +2 >> /tmp/cpu_usage.$$
sleep $UNIT_TIME
done

echo
echo CPU eaters :
cat /tmp/cpu_usage.$$ | \
awk '
{ process[$1]+=$2; }
END{
for(i in process)
{
printf("%-20s %s\n",i, process[i]) ;
}
}' | sort -nrk 2 | head
rm /tmp/cpu_usage.$$
```
