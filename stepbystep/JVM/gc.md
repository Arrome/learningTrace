# GC算法
### 复制算法
适用场景：存活对象较少，垃圾对象多（新生代）
核心思想：将原有的内存空间分为两块，每次只使用其中一块，垃圾回收时，将正在使用的内存中存活对象复制到未使用的内存块中
    之后，清除正在使用的内存块中的所有对象，交换俩个内存的角色，完成垃圾回收
理由：确保回收后的内存空间没有碎片。



### 标记压缩算法
适用场景：（老年代）
核心思想：从根节点开始，对所有可达对象做一次标记，之后并非简单清理未标记对象，而是将所有存活对象压缩到内存一端，清理边界外的所有空间。
    避免了碎片产生，又不需要两块相同内存空间。
    
# GC收集器
###串行收集器
场景：新生代｜老年代
核心：单线程，独占式垃圾回收，并行能力差的计算机，性能更好表现
特点：垃圾回收时，Java程序所有线程都要暂停，等待垃圾回收完成。（STW）

###ParNew回收器
场景：新生代
特点：简单将串行收集器多线程化，多线程，独占式同时进行回收

###ParallelGC 并行回收器
场景：新生代
特点：复制算法的收集器。同ParNew，不同点：关注系统吞吐量（设置系统停顿时间和吞吐量），支持自适应GC调节策略（新生代大小，eden和survivior的比例、晋升老年代对象年龄等参数会被自动调整，以达到堆大小、吞吐量和停顿时间间的平衡点）

###ParallelOldGC 回收器
场景：老年代
特点：标记压缩算法

###CMS 回收器
